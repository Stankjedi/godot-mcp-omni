export function inputManagerScript(): string {
  return [
    'extends Node',
    'class_name InputManager',
    '',
    'enum Context { GAMEPLAY, UI, CUTSCENE }',
    '',
    'const DEFAULT_KEY_BINDINGS := {',
    '  "move_left": [KEY_A, KEY_LEFT],',
    '  "move_right": [KEY_D, KEY_RIGHT],',
    '  "move_up": [KEY_W, KEY_UP],',
    '  "move_down": [KEY_S, KEY_DOWN],',
    '  "jump": [KEY_SPACE],',
    '  "attack": [KEY_J],',
    '  "dash": [KEY_K],',
    '  "interact": [KEY_E],',
    '  "pause": [KEY_ESCAPE],',
    '  "ui_up": [KEY_UP],',
    '  "ui_down": [KEY_DOWN],',
    '  "ui_left": [KEY_LEFT],',
    '  "ui_right": [KEY_RIGHT],',
    '  "ui_accept": [KEY_ENTER, KEY_SPACE],',
    '  "ui_cancel": [KEY_ESCAPE],',
    '}',
    '',
    'const UI_ACTIONS := {',
    '  "ui_up": true,',
    '  "ui_down": true,',
    '  "ui_left": true,',
    '  "ui_right": true,',
    '  "ui_accept": true,',
    '  "ui_cancel": true,',
    '  "pause": true,',
    '}',
    '',
    'var _context: Context = Context.GAMEPLAY',
    'var _bindings_path := "user://input_bindings.cfg"',
    '',
    'func _ready() -> void:',
    '  _ensure_default_actions()',
    '  load_bindings()',
    '',
    'func set_context(ctx: Context) -> void:',
    '  _context = ctx',
    '',
    'func get_context() -> Context:',
    '  return _context',
    '',
    'func get_move_vector() -> Vector2:',
    '  if _context != Context.GAMEPLAY:',
    '    return Vector2.ZERO',
    '  var x := Input.get_action_strength("move_right") - Input.get_action_strength("move_left")',
    '  var y := Input.get_action_strength("move_down") - Input.get_action_strength("move_up")',
    '  var v := Vector2(x, y)',
    '  return v.normalized() if v.length() > 1.0 else v',
    '',
    'func was_pressed(action: StringName) -> bool:',
    '  if _context != Context.GAMEPLAY and not UI_ACTIONS.has(String(action)):',
    '    return false',
    '  return Input.is_action_just_pressed(action)',
    '',
    'func is_down(action: StringName) -> bool:',
    '  if _context != Context.GAMEPLAY and not UI_ACTIONS.has(String(action)):',
    '    return false',
    '  return Input.is_action_pressed(action)',
    '',
    'func rebind_action(action: String, keycode: int) -> void:',
    '  if not InputMap.has_action(action):',
    '    InputMap.add_action(action)',
    '  InputMap.action_erase_events(action)',
    '  var e := InputEventKey.new()',
    '  e.keycode = keycode',
    '  InputMap.action_add_event(action, e)',
    '  save_bindings()',
    '',
    'func save_bindings() -> void:',
    '  var cfg := ConfigFile.new()',
    '  for a in InputMap.get_actions():',
    '    var events := []',
    '    for ev in InputMap.action_get_events(a):',
    '      if ev is InputEventKey:',
    '        events.append((ev as InputEventKey).keycode)',
    '    cfg.set_value("bindings", String(a), events)',
    '  cfg.save(_bindings_path)',
    '',
    'func load_bindings() -> void:',
    '  var cfg := ConfigFile.new()',
    '  var err := cfg.load(_bindings_path)',
    '  if err != OK:',
    '    _apply_defaults()',
    '    return',
    '  for a in cfg.get_section_keys("bindings"):',
    '    var codes := cfg.get_value("bindings", a, [])',
    '    if codes is Array:',
    '      InputMap.action_erase_events(a)',
    '      for code in codes:',
    '        if typeof(code) == TYPE_INT:',
    '          var e := InputEventKey.new()',
    '          e.keycode = int(code)',
    '          InputMap.action_add_event(a, e)',
    '',
    'func _ensure_default_actions() -> void:',
    '  for a in DEFAULT_KEY_BINDINGS.keys():',
    '    if not InputMap.has_action(a):',
    '      InputMap.add_action(a)',
    '',
    'func _apply_defaults() -> void:',
    '  for a in DEFAULT_KEY_BINDINGS.keys():',
    '    InputMap.action_erase_events(a)',
    '    for code in DEFAULT_KEY_BINDINGS[a]:',
    '      var e := InputEventKey.new()',
    '      e.keycode = int(code)',
    '      InputMap.action_add_event(a, e)',
    '',
  ].join('\n');
}

export function playerControllerScript(): string {
  return [
    'extends CharacterBody2D',
    'class_name PlayerController',
    '',
    '@export var speed := 160.0',
    '@export var jump_velocity := -320.0',
    '@export var gravity := 900.0',
    '@export var coyote_time := 0.08',
    '@export var jump_buffer := 0.08',
    '',
    'var _coyote_left := 0.0',
    'var _jump_buffer_left := 0.0',
    '',
    'func _physics_process(delta: float) -> void:',
    '  _coyote_left = maxf(0.0, _coyote_left - delta)',
    '  _jump_buffer_left = maxf(0.0, _jump_buffer_left - delta)',
    '',
    '  if is_on_floor():',
    '    _coyote_left = coyote_time',
    '',
    '  if Input.is_action_just_pressed("jump"):',
    '    _jump_buffer_left = jump_buffer',
    '',
    '  velocity.y += gravity * delta',
    '',
    '  var input_x := Input.get_action_strength("move_right") - Input.get_action_strength("move_left")',
    '  velocity.x = input_x * speed',
    '',
    '  if _jump_buffer_left > 0.0 and _coyote_left > 0.0:',
    '    _jump_buffer_left = 0.0',
    '    _coyote_left = 0.0',
    '    velocity.y = jump_velocity',
    '',
    '  move_and_slide()',
    '',
  ].join('\n');
}

export function cameraRigScript(): string {
  return [
    'extends Node2D',
    'class_name CameraRig2D',
    '',
    '@export var target_path: NodePath',
    '@export var follow_strength := 12.0',
    '@export var look_ahead := 28.0',
    '',
    '@onready var _cam: Camera2D = $Camera2D',
    '',
    'func _physics_process(delta: float) -> void:',
    '  var target := get_node_or_null(target_path) as Node2D',
    '  if target == null:',
    '    return',
    '  var desired := target.global_position',
    '  var v := Vector2.ZERO',
    '  if "velocity" in target:',
    '    v = target.velocity',
    '  desired += v.normalized() * look_ahead',
    '  global_position = global_position.lerp(desired, 1.0 - exp(-follow_strength * delta))',
    '',
  ].join('\n');
}

export function animationStateMachineScript(): string {
  return [
    'extends Node',
    'class_name AnimationStateMachine',
    '',
    '@export var initial_state := "idle"',
    '',
    'var state := ""',
    '',
    'func _ready() -> void:',
    '  state = initial_state',
    '',
    'func transition(next_state: String) -> void:',
    '  if next_state == state:',
    '    return',
    '  state = next_state',
    '  # TODO: notify Animator / AnimationTree here',
    '',
  ].join('\n');
}

export function combatScripts(): Record<string, string> {
  return {
    'res://scripts/macro/combat/DamagePayload.gd': [
      'extends Resource',
      'class_name DamagePayload',
      '',
      '@export var amount := 1',
      '@export var knockback := Vector2.ZERO',
      '@export var stun := 0.0',
      '',
    ].join('\n'),

    'res://scripts/macro/combat/Health.gd': [
      'extends Node',
      'class_name Health',
      '',
      'signal damaged(payload)',
      'signal died()',
      '',
      '@export var max_hp := 3',
      'var hp := 0',
      '',
      'func _ready() -> void:',
      '  hp = max_hp',
      '',
      'func apply_damage(payload: DamagePayload) -> void:',
      '  hp -= payload.amount',
      '  damaged.emit(payload)',
      '  if hp <= 0:',
      '    died.emit()',
      '',
    ].join('\n'),

    'res://scripts/macro/combat/Hitbox.gd': [
      'extends Area2D',
      'class_name Hitbox',
      '',
      '@export var payload: DamagePayload',
      '',
    ].join('\n'),

    'res://scripts/macro/combat/Hurtbox.gd': [
      'extends Area2D',
      'class_name Hurtbox',
      '',
      '@export var health_path: NodePath',
      '',
      'func _ready() -> void:',
      '  area_entered.connect(_on_area_entered)',
      '',
      'func _on_area_entered(a: Area2D) -> void:',
      '  var hit := a as Hitbox',
      '  if hit == null or hit.payload == null:',
      '    return',
      '  var h := get_node_or_null(health_path) as Health',
      '  if h != null:',
      '    h.apply_damage(hit.payload)',
      '',
    ].join('\n'),
  };
}

export function fsmScripts(): Record<string, string> {
  return {
    'res://scripts/macro/ai/FSM.gd': [
      'extends Node',
      'class_name FSM',
      '',
      'var state: Node = null',
      '',
      'func set_state(next: Node) -> void:',
      '  if state == next:',
      '    return',
      '  if state != null and state.has_method("exit"):',
      '    state.exit()',
      '  state = next',
      '  if state != null and state.has_method("enter"):',
      '    state.enter()',
      '',
      'func _physics_process(delta: float) -> void:',
      '  if state != null and state.has_method("tick"):',
      '    state.tick(delta)',
      '',
    ].join('\n'),

    'res://scripts/macro/ai/Enemy.gd': [
      'extends CharacterBody2D',
      'class_name Enemy',
      '',
      '@export var speed := 80.0',
      '',
      'func _physics_process(delta: float) -> void:',
      '  velocity.y += 900.0 * delta',
      '  move_and_slide()',
      '',
    ].join('\n'),
  };
}

export function saveManagerScript(): string {
  return [
    'extends Node',
    'class_name SaveManager',
    '',
    'const SAVE_VERSION := 1',
    'const SAVE_DIR := "user://saves/"',
    '',
    'func save_slot(slot: int, data: Dictionary) -> void:',
    '  DirAccess.make_dir_recursive_absolute(SAVE_DIR)',
    '  var file := FileAccess.open(SAVE_DIR + "slot_%d.json" % slot, FileAccess.WRITE)',
    '  if file == null:',
    '    push_error("Failed to open save file")',
    '    return',
    '  data["version"] = SAVE_VERSION',
    '  file.store_string(JSON.stringify(data))',
    '',
    'func load_slot(slot: int) -> Dictionary:',
    '  var path := SAVE_DIR + "slot_%d.json" % slot',
    '  if not FileAccess.file_exists(path):',
    '    return {}',
    '  var file := FileAccess.open(path, FileAccess.READ)',
    '  if file == null:',
    '    push_error("Failed to open save file")',
    '    return {}',
    '  var txt := file.get_as_text()',
    '  var parsed := JSON.parse_string(txt)',
    '  if typeof(parsed) != TYPE_DICTIONARY:',
    '    return {}',
    '  return parsed',
    '',
  ].join('\n');
}

export function audioManagerScript(): string {
  return [
    'extends Node',
    'class_name AudioManager',
    '',
    '# MVP: implement an audio facade; set up buses/snapshots in the editor or via a dedicated pipeline later.',
    '',
    '@export var bus_bgm := "BGM"',
    '@export var bus_sfx := "SFX"',
    '@export var bus_ui := "UI"',
    '',
    'var _bgm: AudioStreamPlayer = null',
    '',
    'func _ready() -> void:',
    '  _bgm = AudioStreamPlayer.new()',
    '  _bgm.bus = bus_bgm',
    '  add_child(_bgm)',
    '',
    'func play_bgm(stream: AudioStream, fade: float = 0.0) -> void:',
    '  _bgm.stream = stream',
    '  _bgm.play()',
    '',
    'func stop_bgm(fade: float = 0.0) -> void:',
    '  _bgm.stop()',
    '',
    'func play_sfx(stream: AudioStream, position: Vector2 = Vector2.ZERO, volume_db: float = 0.0, pitch: float = 1.0) -> void:',
    '  var p := AudioStreamPlayer2D.new()',
    '  p.stream = stream',
    '  p.bus = bus_sfx',
    '  p.volume_db = volume_db',
    '  p.pitch_scale = pitch',
    '  p.global_position = position',
    '  add_child(p)',
    '  p.play()',
    '  p.finished.connect(func(): p.queue_free())',
    '',
  ].join('\n');
}

export function uiManagerScript(): string {
  return [
    'extends Node',
    'class_name UIManager',
    '',
    'signal pause_requested',
    'signal resume_requested',
    '',
    'var paused := false',
    '',
    'func toggle_pause() -> void:',
    '  paused = not paused',
    '  if paused:',
    '    pause_requested.emit()',
    '  else:',
    '    resume_requested.emit()',
    '',
  ].join('\n');
}
